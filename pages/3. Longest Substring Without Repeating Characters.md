- #Hashmap #String #[[Sliding Window]] #[[Dictionary/Map]]
- Goal
	- We are given a string s and we need to find the longest substring which is without duplicate characters
- Thinking Behind the Algorithm
	- We want to limit our variables to keep our memory allocation low, so we will define a longest (which will store the length of our longest substring), a left and right pointer (define the boundary of our sliding window), finally we want a [[Dictionary/Map]] to translate character values to the last index we saw that character. We define our right pointer within a for loop which will traverse the entire string. In each iteration we check if the character in the s at the right pointer is already in the our [[Character]] to index map. If it is we advance the left pointer if that last instance of the [[Character]]. After that we want to set longest to the larger of itself or the current size of the window. The we want to set the char to index map for the character at r to r. After this loop we can return longest which will have the longest substring without repeating characters
- Implementation
	- [[C++ Implementation]] #card
		- ```
		  class Solution {
		  public:
		      int lengthOfLongestSubstring(string s) {
		          int longest = 0;
		          int l = 0;
		          unordered_map<char, int> mapi = {};
		          for(int r = 0; r < s.length(); ++r){
		              if (mapi.find(s[r]) != mapi.end()){
		                  l = l > mapi[s[r]] ? l : mapi[s[r]] + 1;
		              }
		              longest = longest > r - l ? longest : r - l + 1;
		              mapi[s[r]] = r;
		          }
		          return longest;
		      }
		  };
		  ```
	- [[Javascript Implementation]] #card
		- ```
		  /**
		   * @param {string} s
		   * @return {number}
		   */
		  var lengthOfLongestSubstring = function(s) {
		      let longest = 0
		      let l = 0
		      d_i = {}
		      for(let r = 0; r < s.length; r++){
		          if (s[r] in d_i){
		              l = l > d_i[s[r]] ? l : d_i[s[r]] + 1
		          }
		          longest = longest > r - l +1 ? longest : r - l + 1
		          d_i[s[r]] = r
		      }
		      return longest
		  };
		  ```
	- [[Python Implementation]] #card
		- ```
		  class Solution:
		      def lengthOfLongestSubstring(self, s: str) -> int:
		          l = 0
		          char_i = {}
		          max_sub = 0
		          for r in range(len(s)):
		              if s[r] not in char_i or char_i[s[r]] < l:
		                  char_i[s[r]] = r
		                  max_sub = max(max_sub, r - l + 1)
		              else:
		                  l = char_i[s[r]] + 1
		                  char_i[s[r]] = r
		              
		          return max_sub
		  ```
- Image to Remember
	- TODO Create image to remember longest Substring without repeating Characters